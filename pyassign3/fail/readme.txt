============= Sang  2018/12/16 06:42 =============
fail.py 中的第11-39行新加一个函数recur()，实现递归。
第216-220行main()函数添加调用recur()的语句取代了调用dissect()的语句。
==================================================

============= Sang  2018/12/16 04:45 =============
fail.py 中写有我最初的算法。
它是不使用常规方法的解法之一。
算法的思路是把一整面墙拆成各个小块，同时判断：
    if 小块无法铺砖: #check_pat()函数:
        舍弃这一铺法
    elif 小块还不能刚好被一块砖铺满: #check_tile()函数
        将小块再分小 #split()函数
    else:
        每个小块都刚好被一块砖铺满，得到解法
例如3*2的 [0, 1, 2, 3, 4, 5] 的墙,
    第一步，切成 [0, 3] 和 [1, 2, 4, 5]
    第二步，保留 [0, 3]，再切出 [1, 2] 和 [4, 5]
    从而，得到一组解 [(0, 3), (1, 2), (4, 5)]
        
fail.py 这个程序没有使用递归，一直拿着一个巨大无比的二维列表参来参去，导致计算量十分低下。
找时间想把它改成用递归进行，效果应该会好很多。

但是
这种算法在较大的情况内存不够根本跑不完的情况下，小情况还是出现了bug
在 (M, N, m, n) = (8, 6, 3, 2) 的这一情况下，程序只解了3组解，并没有解出
    [(0, 1, 2, 8, 9, 10), 
    (3, 4, 11, 12, 19, 20), 
    (5, 6, 7, 13, 14, 15), 
    (16, 17, 18, 24, 25, 26), 
    (21, 22, 23, 29, 30, 31), 
    (27, 28, 35, 36, 43, 44), 
    (32, 33, 34, 40, 41, 42), 
    (37, 38, 39, 45, 46, 47)] 
这一组解（这组解的形状类似于汉字的“王”），原因不明。

fail.py 这个程序里的 input_t()函数, choose_t()函数, paint()函数 被稍作改动之后直接加在了 tile.py 中，
这样子节省了我的时间，然而对其他人来说可能显得 tile.py 这部分有些冗杂，对此造成的不便十分抱歉。
==================================================


